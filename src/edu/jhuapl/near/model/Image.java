package edu.jhuapl.near.model;

import java.beans.PropertyChangeEvent;
import java.beans.PropertyChangeListener;
import java.io.BufferedReader;
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.ArrayList;
import java.util.LinkedHashMap;

import nom.tam.fits.BasicHDU;
import nom.tam.fits.Fits;
import nom.tam.fits.FitsException;

import vtk.vtkActor;
import vtk.vtkCell;
import vtk.vtkCellArray;
import vtk.vtkDataArray;
import vtk.vtkFeatureEdges;
import vtk.vtkFloatArray;
import vtk.vtkGenericCell;
import vtk.vtkIdList;
import vtk.vtkImageCanvasSource2D;
import vtk.vtkImageData;
import vtk.vtkImageMapToColors;
import vtk.vtkImageMask;
import vtk.vtkLookupTable;
import vtk.vtkPointData;
import vtk.vtkPoints;
import vtk.vtkPolyData;
import vtk.vtkPolyDataMapper;
import vtk.vtkPolyDataNormals;
import vtk.vtkProp;
import vtk.vtkProperty;
import vtk.vtkTexture;
import vtk.vtkXMLPolyDataReader;
import vtk.vtksbCellLocator;

import edu.jhuapl.near.util.BoundingBox;
import edu.jhuapl.near.util.FileCache;
import edu.jhuapl.near.util.Frustum;
import edu.jhuapl.near.util.IntensityRange;
import edu.jhuapl.near.util.LatLon;
import edu.jhuapl.near.util.MathUtil;
import edu.jhuapl.near.util.PolyDataUtil;
import edu.jhuapl.near.util.Properties;

/**
 * This class represents an absract image of a spacecraft imager instrument.
 *
 * @author kahneg1
 *
 */
abstract public class Image extends Model implements PropertyChangeListener
{
    public static final float PDS_NA = -1.e32f;

    private SmallBodyModel smallBodyModel;

    private vtkImageData rawImage;
    private vtkImageData displayedImage;

    private vtkPolyData footprint;
    private vtkPolyData shiftedFootprint;
    private vtkActor footprintActor;
    private ArrayList<vtkProp> footprintActors = new ArrayList<vtkProp>();

    private vtkActor frustumActor;

    private vtkPolyDataNormals normalsFilter;

    private vtkFloatArray textureCoords;

    private boolean footprintGenerated = false;
    private boolean normalsGenerated = false;

    private double minIncidence = Double.MAX_VALUE;
    private double maxIncidence = -Double.MAX_VALUE;
    private double minEmission = Double.MAX_VALUE;
    private double maxEmission = -Double.MAX_VALUE;
    private double minPhase = Double.MAX_VALUE;
    private double maxPhase = -Double.MAX_VALUE;
    private double minHorizontalPixelScale = Double.MAX_VALUE;
    private double maxHorizontalPixelScale = -Double.MAX_VALUE;
    private double meanHorizontalPixelScale = 0.0;
    private double minVerticalPixelScale = Double.MAX_VALUE;
    private double maxVerticalPixelScale = -Double.MAX_VALUE;
    private double meanVerticalPixelScale = 0.0;

    private float minValue;
    private float maxValue;
    private IntensityRange displayedRange = new IntensityRange(1,0);

    private double[] spacecraftPosition = new double[3];
    private double[] frustum1 = new double[3];
    private double[] frustum2 = new double[3];
    private double[] frustum3 = new double[3];
    private double[] frustum4 = new double[3];
    private double[] sunVector = new double[3];

    private double[] boresightDirection = new double[3];
    private double[] upVector = new double[3];

    private boolean showFrustum = false;

    private String startTime = "";
    private String stopTime = "";

    private ImageKey key;
    private vtkImageCanvasSource2D maskSource;

    private int imageWidth;

    private int imageHeight;

    private String fitFileFullPath; // The actual path of the image stored on the local disk (after downloading from the server)
    private String infoFileFullPath;
    private String sumfileFullPath;

    // If true, then the footprint is generated by intersecting a frustum with the asteroid.
    // This setting is used when generating the files on the server.
    // If false, then the footprint is downloaded from the server. This setting is used by the GUI.
    private static boolean generateFootprint = true;

    // If true the footprint will be loaded from the local disk rather than being
    // downloaded from from the server
    private static boolean footprintIsOnLocalDisk = false;

    public enum ImageSource
    {
        PDS {
            public String toString()
            {
                return "PDS derived";
            }
        },
        GASKELL {
            public String toString()
            {
                return "Gaskell derived";
            }
        }
    };

    /**
     * An ImageKey should be used to uniquely distinguish one image from another.
     * No two images will have the same values for the fields of this class.
     * @author kahn
     *
     */
    public static class ImageKey
    {
        // The path of the image as passed into the constructor. This is not the
        // same as fullpath but instead corresponds to the name needed to download
        // the file from the server (excluding the hostname and extension).
        public String name;

        public ImageSource source;

        public ImageKey()
        {
        }

        public ImageKey(String name, ImageSource source)
        {
            this.name = name;
            this.source = source;
        }

        @Override
        public boolean equals(Object obj)
        {
            return name.equals(((ImageKey)obj).name) && source == ((ImageKey)obj).source;
        }
    }

    /**
     * If loadPointingOnly is true then only pointing information about this
     * image will be downloaded/loaded. The image itself will not be loaded.
     * Used by ImageBoundary to get pointing info.
     *
     * If rootFolder is not null, then rather than downloading the relevant files
     * from the server, this class will assume that all files are located on
     * the local disk under rootFolder. The image key specifies the remaining
     * part of the path for the files. Setting rootFolder to something non-null
     * is only done by the server programs in the server package. The GUI program
     * should always set this value to null since it always downloads the files.
     */
    public Image(ImageKey key,
            SmallBodyModel smallBodyModel,
            boolean loadPointingOnly,
            File rootFolder) throws FitsException, IOException
    {
        this.key = key;
        this.smallBodyModel = smallBodyModel;

        if (!loadPointingOnly)
            fitFileFullPath = initializeFitFileFullPath(rootFolder);

        infoFileFullPath = initializeInfoFileFullPath(rootFolder);

        if (key.source.equals(ImageSource.GASKELL))
            sumfileFullPath = initializeSumfileFullPath(rootFolder);

        loadPointing();

        if (!loadPointingOnly)
            loadImage();
    }

    abstract protected void loadImageInfo(
            String lblFilename,
            String[] startTime,
            String[] stopTime,
            double[] spacecraftPosition,
            double[] sunVector,
            double[] frustum1,
            double[] frustum2,
            double[] frustum3,
            double[] frustum4,
            double[] boresightDirection,
            double[] upVector) throws NumberFormatException, IOException;

    abstract public double getFovParameter1();
    abstract public double getFovParameter2();

    /**
     * Return the mask sizes as a 4 element integer array where the:
     * first  element is the top    mask size,
     * second element is the right  mask size,
     * third  element is the bottom mask size,
     * fourth element is the left   mask size.
     * @return
     */
    abstract protected int[] getMaskSizes();

    abstract protected int getFilter();

    abstract public String generateBackplanesLabel() throws IOException;
    abstract public LinkedHashMap<String, String> getProperties() throws IOException;

    abstract protected String initializeFitFileFullPath(File rootFolder);
    abstract protected String initializeInfoFileFullPath(File rootFolder);
    abstract protected String initializeSumfileFullPath(File rootFolder);

    public int getImageWidth()
    {
        return imageWidth;
    }

    public int getImageHeight()
    {
        return imageHeight;
    }

    protected String getFitFileFullPath()
    {
        return fitFileFullPath;
    }

    protected String getInfoFileFullPath()
    {
        return infoFileFullPath;
    }

    protected String getSumfileFullPath()
    {
        return sumfileFullPath;
    }

    /**
     *  Give oppurtunity to subclass to resize raw image
     * @param rawImage
     */
    protected void resizeRawImage(vtkImageData rawImage)
    {
        // By default do nothing
    }

    protected void loadImage() throws FitsException, IOException
    {
        String filename = getFitFileFullPath();

        Fits f = new Fits(filename);
        BasicHDU h = f.getHDU(0);

        float[][] array = null;
        int[] axes = h.getAxes();
        int originalWidth = axes[1];
        int originalHeight = axes[0];

        Object data = h.getData().getData();
        if (data instanceof float[][])
        {
            array = (float[][])data;
        }
        else if (data instanceof short[][])
        {
            short[][] arrayS = (short[][])data;
            array = new float[originalHeight][originalWidth];

            for (int i=0; i<originalHeight; ++i)
                for (int j=0; j<originalWidth; ++j)
                {
                    array[i][j] = arrayS[i][j];
                }
        }
        else if (data instanceof byte[][])
        {
            byte[][] arrayB = (byte[][])data;
            array = new float[originalHeight][originalWidth];

            for (int i=0; i<originalHeight; ++i)
                for (int j=0; j<originalWidth; ++j)
                {
                    array[i][j] = arrayB[i][j];
                }
        }
        else
        {
            System.out.println("Data type not supported!");
            return;
        }

        rawImage = new vtkImageData();
        rawImage.SetScalarTypeToFloat();
        rawImage.SetDimensions(originalWidth, originalHeight, 1);
        rawImage.SetSpacing(1.0, 1.0, 1.0);
        rawImage.SetOrigin(0.0, 0.0, 0.0);
        rawImage.SetNumberOfScalarComponents(1);

        maxValue = -Float.MAX_VALUE;
        minValue = Float.MAX_VALUE;
        for (int i=0; i<originalHeight; ++i)
            for (int j=0; j<originalWidth; ++j)
            {
                rawImage.SetScalarComponentFromDouble(j, originalHeight-1-i, 0, 0, array[i][j]);

                if (array[i][j] > maxValue)
                    maxValue = array[i][j];
                if (array[i][j] < minValue)
                    minValue = array[i][j];
            }

        resizeRawImage(rawImage);

        int[] dims = rawImage.GetDimensions();
        imageWidth = dims[0];
        imageHeight = dims[1];

        int[] masking = getMaskSizes();
        int topMask =    masking[0];
        int rightMask =  masking[1];
        int bottomMask = masking[2];
        int leftMask =   masking[3];

        maskSource = new vtkImageCanvasSource2D();
        maskSource.SetScalarTypeToUnsignedChar();
        maskSource.SetNumberOfScalarComponents(1);
        maskSource.SetExtent(0, imageWidth-1, 0, imageHeight-1, 0, 0);
        // Initialize the mask to black which masks out the image
        maskSource.SetDrawColor(0.0, 0.0, 0.0, 0.0);
        maskSource.FillBox(0, imageWidth-1, 0, imageHeight-1);
        // Create a square inside mask which passes through the image.
        maskSource.SetDrawColor(255.0, 255.0, 255.0, 255.0);
        maskSource.FillBox(leftMask, imageWidth-1-rightMask, bottomMask, imageHeight-1-topMask);
        maskSource.Update();

        setDisplayedImageRange(new IntensityRange(0, 255));


        footprint = new vtkPolyData();
        shiftedFootprint = new vtkPolyData();
        textureCoords = new vtkFloatArray();
        normalsFilter = new vtkPolyDataNormals();
    }

    protected void loadPointing() throws FitsException, IOException
    {
        loadImageInfo();

        // If the sumfile exists, then load it after we load the LBL file
        // so as to overwrite whatever was loaded from the LBL file.
        if (key.source.equals(ImageSource.GASKELL))
        {
            try
            {
                loadSumfile();
            }
            catch(IOException ex)
            {
                System.out.println("Sumfile not available");
            }
        }
    }

    public ImageKey getKey()
    {
        return key;
    }

    public vtkImageData getRawImage()
    {
        return rawImage;
    }

    public vtkImageData getDisplayedImage()
    {
        return displayedImage;
    }

    public static void setGenerateFootprint(boolean b)
    {
        generateFootprint = b;
    }

    public static void setFootprintIsOnLocalDisk(boolean b)
    {
        footprintIsOnLocalDisk = b;
    }

    public ArrayList<vtkProp> getProps()
    {
        if (footprintActor == null)
        {
            loadFootprint();

            vtkTexture texture = new vtkTexture();
            texture.InterpolateOn();
            texture.RepeatOff();
            texture.EdgeClampOn();
            texture.SetInput(displayedImage);

            vtkPolyDataMapper footprintMapper = new vtkPolyDataMapper();
            footprintMapper.SetInput(shiftedFootprint);
            footprintMapper.Update();

            footprintActor = new vtkActor();
            footprintActor.SetMapper(footprintMapper);
            footprintActor.SetTexture(texture);
            vtkProperty footprintProperty = footprintActor.GetProperty();
            footprintProperty.LightingOff();

            footprintActors.add(footprintActor);
        }

        if (frustumActor == null)
        {
            vtkPolyData frus = new vtkPolyData();

            vtkPoints points = new vtkPoints();
            vtkCellArray lines = new vtkCellArray();

            vtkIdList idList = new vtkIdList();
            idList.SetNumberOfIds(2);

            double dx = MathUtil.vnorm(spacecraftPosition) + smallBodyModel.getBoundingBoxDiagonalLength();
            double[] origin = spacecraftPosition;
            double[] UL = {origin[0]+frustum1[0]*dx, origin[1]+frustum1[1]*dx, origin[2]+frustum1[2]*dx};
            double[] UR = {origin[0]+frustum2[0]*dx, origin[1]+frustum2[1]*dx, origin[2]+frustum2[2]*dx};
            double[] LL = {origin[0]+frustum3[0]*dx, origin[1]+frustum3[1]*dx, origin[2]+frustum3[2]*dx};
            double[] LR = {origin[0]+frustum4[0]*dx, origin[1]+frustum4[1]*dx, origin[2]+frustum4[2]*dx};

            points.InsertNextPoint(spacecraftPosition);
            points.InsertNextPoint(UL);
            points.InsertNextPoint(UR);
            points.InsertNextPoint(LL);
            points.InsertNextPoint(LR);

            idList.SetId(0, 0);
            idList.SetId(1, 1);
            lines.InsertNextCell(idList);
            idList.SetId(0, 0);
            idList.SetId(1, 2);
            lines.InsertNextCell(idList);
            idList.SetId(0, 0);
            idList.SetId(1, 3);
            lines.InsertNextCell(idList);
            idList.SetId(0, 0);
            idList.SetId(1, 4);
            lines.InsertNextCell(idList);

            frus.SetPoints(points);
            frus.SetLines(lines);


            vtkPolyDataMapper frusMapper = new vtkPolyDataMapper();
            frusMapper.SetInput(frus);

            frustumActor = new vtkActor();
            frustumActor.SetMapper(frusMapper);
            vtkProperty frustumProperty = frustumActor.GetProperty();
            frustumProperty.SetColor(0.0, 1.0, 0.0);
            frustumProperty.SetLineWidth(2.0);
            frustumActor.VisibilityOff();

            footprintActors.add(frustumActor);
        }

        return footprintActors;
    }

    public void setShowFrustum(boolean b)
    {
        showFrustum = b;

        if (showFrustum)
        {
            frustumActor.VisibilityOn();
        }
        else
        {
            frustumActor.VisibilityOff();
        }
    }

    public boolean isFrustumShowing()
    {
        return showFrustum;
    }

    public double getMinIncidence()
    {
        return minIncidence;
    }

    public double getMaxIncidence()
    {
        return maxIncidence;
    }

    public double getMinEmission()
    {
        return minEmission;
    }

    public double getMaxEmission()
    {
        return maxEmission;
    }

    public double getMinPhase()
    {
        return minPhase;
    }

    public double getMaxPhase()
    {
        return maxPhase;
    }

    public IntensityRange getDisplayedRange()
    {
        return displayedRange;
    }

    public void setDisplayedImageRange(IntensityRange range)
    {
        if (displayedRange.min != range.min ||
                displayedRange.max != range.max)
        {
            displayedRange = range;

            float dx = (maxValue-minValue)/255.0f;
            float min = minValue + range.min*dx;
            float max = minValue + range.max*dx;

            // Update the displayed image
            vtkLookupTable lut = new vtkLookupTable();
            lut.SetTableRange(min, max);
            lut.SetValueRange(0.0, 1.0);
            lut.SetHueRange(0.0, 0.0);
            lut.SetSaturationRange(0.0, 0.0);
            //lut.SetNumberOfTableValues(402);
            lut.SetRampToLinear();
            lut.Build();

            vtkImageMapToColors mapToColors = new vtkImageMapToColors();
            mapToColors.SetInput(rawImage);
            mapToColors.SetOutputFormatToRGBA();
            mapToColors.SetLookupTable(lut);
            mapToColors.Update();

            vtkImageMask maskFilter = new vtkImageMask();
            maskFilter.SetImageInput(mapToColors.GetOutput());
            maskFilter.SetMaskInput(maskSource.GetOutput());
            maskFilter.Update();

            if (displayedImage == null)
                displayedImage = new vtkImageData();
            vtkImageData mapToColorsOutput = maskFilter.GetOutput();
            displayedImage.DeepCopy(mapToColorsOutput);

            maskFilter.Delete();
            mapToColors.Delete();
            lut.Delete();

            //vtkPNGWriter writer = new vtkPNGWriter();
            //writer.SetFileName("fit.png");
            //writer.SetInput(displayedImage);
            //writer.Write();

            this.pcs.firePropertyChange(Properties.MODEL_CHANGED, null, null);
        }
    }

//    private static void printpt(double[] p, String s)
//    {
//        System.out.println(s + " " + p[0] + " " + p[1] + " " + p[2]);
//    }


    private void loadImageInfo() throws NumberFormatException, IOException
    {
        String lblFilename = getInfoFileFullPath();

        String[] start = new String[1];
        String[] stop = new String[1];
        loadImageInfo(
                lblFilename,
                start,
                stop,
                spacecraftPosition,
                sunVector,
                frustum1,
                frustum2,
                frustum3,
                frustum4,
                boresightDirection,
                upVector);

        startTime = start[0];
        stopTime = stop[0];

//        printpt(frustum1, "pds frustum1 ");
//        printpt(frustum2, "pds frustum2 ");
//        printpt(frustum3, "pds frustum3 ");
//        printpt(frustum4, "pds frustum4 ");
    }

    /**
     * Sometimes Bob Gaskell sumfiles contain numbers of the form
     * .1192696009D+03 rather than .1192696009E+03 (i.e. a D instead
     * of an E). This function replaces D's with E's.
     * @param s
     * @return
     */
    private void replaceDwithE(String[] s)
    {
        for (int i=0; i<s.length; ++i)
            s[i] = s[i].replace('D', 'E');
    }

    /**
     * Bob Gaskell's date time format needs to be converted to
     * yyyy-MM-dd'T'HH:mm:ss.SSS format.
     *
     * @param datetime
     * @return
     */
    private String convertDateTimeFormat(String datetime)
    {
        String[] tokens = datetime.trim().split("\\s+");

        String year  = tokens[0];
        String month = tokens[1];
        String day   = tokens[2];
        String time  = tokens[3];

        if (month.equals("JAN"))
            month = "01";
        else if (month.equals("FEB"))
            month = "02";
        else if (month.equals("MAR"))
            month = "03";
        else if (month.equals("APR"))
            month = "04";
        else if (month.equals("MAY"))
            month = "05";
        else if (month.equals("JUN"))
            month = "06";
        else if (month.equals("JUL"))
            month = "07";
        else if (month.equals("AUG"))
            month = "08";
        else if (month.equals("SEP"))
            month = "09";
        else if (month.equals("OCT"))
            month = "10";
        else if (month.equals("NOV"))
            month = "11";
        else if (month.equals("DEC"))
            month = "12";

        return year + "-" + month + "-" + day + "T" + time;
    }

    protected void loadSumfile(
            String sumfilename,
            double fovParameter1,
            double fovParameter2,
            String[] startTime,
            String[] stopTime,
            double[] spacecraftPosition,
            double[] sunVector,
            double[] frustum1,
            double[] frustum2,
            double[] frustum3,
            double[] frustum4,
            double[] boresightDirection,
            double[] upVector) throws IOException
    {
        FileInputStream fs = new FileInputStream(sumfilename);
        InputStreamReader isr = new InputStreamReader(fs);
        BufferedReader in = new BufferedReader(isr);

        in.readLine();

        String datetime = in.readLine().trim();
        datetime = convertDateTimeFormat(datetime);
        startTime[0] = datetime;
        stopTime[0] = datetime;

        in.readLine();
        in.readLine();

        String[] tmp = in.readLine().trim().split("\\s+");
        replaceDwithE(tmp);
        spacecraftPosition[0] = -Double.parseDouble(tmp[0]);
        spacecraftPosition[1] = -Double.parseDouble(tmp[1]);
        spacecraftPosition[2] = -Double.parseDouble(tmp[2]);

        double[] cx = new double[3];
        double[] cy = new double[3];
        double[] cz = new double[3];
        double[] sz = new double[3];

        tmp = in.readLine().trim().split("\\s+");
        replaceDwithE(tmp);
        cx[0] = Double.parseDouble(tmp[0]);
        cx[1] = Double.parseDouble(tmp[1]);
        cx[2] = Double.parseDouble(tmp[2]);

        tmp = in.readLine().trim().split("\\s+");
        replaceDwithE(tmp);
        cy[0] = Double.parseDouble(tmp[0]);
        cy[1] = Double.parseDouble(tmp[1]);
        cy[2] = Double.parseDouble(tmp[2]);

        tmp = in.readLine().trim().split("\\s+");
        replaceDwithE(tmp);
        cz[0] = Double.parseDouble(tmp[0]);
        cz[1] = Double.parseDouble(tmp[1]);
        cz[2] = Double.parseDouble(tmp[2]);

        tmp = in.readLine().trim().split("\\s+");
        replaceDwithE(tmp);
        sz[0] = Double.parseDouble(tmp[0]);
        sz[1] = Double.parseDouble(tmp[1]);
        sz[2] = Double.parseDouble(tmp[2]);

        double zo = fovParameter1;
        double yo = fovParameter2;
        double fx = zo;
        double fy = yo;
        double fz = 1.0;
        frustum3[0] = fx*cx[0] + fy*cy[0] + fz*cz[0];
        frustum3[1] = fx*cx[1] + fy*cy[1] + fz*cz[1];
        frustum3[2] = fx*cx[2] + fy*cy[2] + fz*cz[2];

        fx = -zo;
        fy = yo;
        fz = 1.0;
        frustum4[0] = fx*cx[0] + fy*cy[0] + fz*cz[0];
        frustum4[1] = fx*cx[1] + fy*cy[1] + fz*cz[1];
        frustum4[2] = fx*cx[2] + fy*cy[2] + fz*cz[2];

        fx = zo;
        fy = -yo;
        fz = 1.0;
        frustum1[0] = fx*cx[0] + fy*cy[0] + fz*cz[0];
        frustum1[1] = fx*cx[1] + fy*cy[1] + fz*cz[1];
        frustum1[2] = fx*cx[2] + fy*cy[2] + fz*cz[2];

        fx = -zo;
        fy = -yo;
        fz = 1.0;
        frustum2[0] = fx*cx[0] + fy*cy[0] + fz*cz[0];
        frustum2[1] = fx*cx[1] + fy*cy[1] + fz*cz[1];
        frustum2[2] = fx*cx[2] + fy*cy[2] + fz*cz[2];

        MathUtil.vhat(frustum1, frustum1);
        MathUtil.vhat(frustum2, frustum2);
        MathUtil.vhat(frustum3, frustum3);
        MathUtil.vhat(frustum4, frustum4);

        MathUtil.vhat(cz, boresightDirection);
        MathUtil.vhat(cx, upVector);
        MathUtil.vhat(sz, sunVector);
    }

    private void loadSumfile() throws NumberFormatException, IOException
    {
        String[] start = new String[1];
        String[] stop = new String[1];

        loadSumfile(
                getSumfileFullPath(),
                getFovParameter1(),
                getFovParameter2(),
                start,
                stop,
                spacecraftPosition,
                sunVector,
                frustum1,
                frustum2,
                frustum3,
                frustum4,
                boresightDirection,
                upVector);

        startTime = start[0];
        stopTime = stop[0];

//        printpt(frustum1, "gas frustum1 ");
//        printpt(frustum2, "gas frustum2 ");
//        printpt(frustum3, "gas frustum3 ");
//        printpt(frustum4, "gas frustum4 ");
    }

    public boolean containsLimb()
    {
        //TODO Speed this up: Determine if there is a limb without computing the entire backplane.

        float[] bp = generateBackplanes(true);
        if (bp == null)
            return true;
        else
            return false;
    }

    public void loadFootprint()
    {
        if (generateFootprint)
        {
            vtkPolyData tmp = smallBodyModel.computeFrustumIntersection(spacecraftPosition,
                    frustum1, frustum3, frustum4, frustum2);

            if (tmp == null)
                return;

            footprint.DeepCopy(tmp);

            vtkPointData pointData = footprint.GetPointData();
            pointData.SetTCoords(textureCoords);
            PolyDataUtil.generateTextureCoordinates(getFrustum(), footprint);
        }
        else
        {
            int resolutionLevel = smallBodyModel.getModelResolution();

            String footprintFilename = null;
            File file = null;

            if (footprintIsOnLocalDisk)
            {
                String fullpath = getFitFileFullPath();
                if (key.source == ImageSource.PDS)
                    footprintFilename = fullpath.substring(0, fullpath.length()-4) + "_FOOTPRINT_RES" + resolutionLevel + "_PDS.VTP";
                else
                    footprintFilename = fullpath.substring(0, fullpath.length()-4) + "_FOOTPRINT_RES" + resolutionLevel + "_GASKELL.VTP";

                file = new File(footprintFilename);
            }
            else
            {
                if (key.source == ImageSource.PDS)
                    footprintFilename = key.name + "_FOOTPRINT_RES" + resolutionLevel + "_PDS.VTP";
                else
                    footprintFilename = key.name + "_FOOTPRINT_RES" + resolutionLevel + "_GASKELL.VTP";

                file = FileCache.getFileFromServer(footprintFilename);
            }

            if (file == null || !file.exists())
            {
                System.out.println("Warning: " + footprintFilename + " not found");
                return;
            }

            vtkXMLPolyDataReader footprintReader = new vtkXMLPolyDataReader();
            footprintReader.SetFileName(file.getAbsolutePath());
            footprintReader.Update();

            vtkPolyData footprintReaderOutput = footprintReader.GetOutput();
            footprint.DeepCopy(footprintReaderOutput);
        }


        shiftedFootprint.DeepCopy(footprint);
        PolyDataUtil.shiftPolyDataInNormalDirection(shiftedFootprint, 2.0*smallBodyModel.getMinShiftAmount());

        footprintGenerated = true;
    }

    public vtkPolyData generateBoundary()
    {
        loadFootprint();

        if (footprint.GetNumberOfPoints() == 0)
            return null;

        vtkFeatureEdges edgeExtracter = new vtkFeatureEdges();
        edgeExtracter.SetInput(footprint);
        edgeExtracter.BoundaryEdgesOn();
        edgeExtracter.FeatureEdgesOff();
        edgeExtracter.NonManifoldEdgesOff();
        edgeExtracter.ManifoldEdgesOff();
        edgeExtracter.Update();

        vtkPolyData boundary = new vtkPolyData();
        vtkPolyData edgeExtracterOutput = edgeExtracter.GetOutput();
        boundary.DeepCopy(edgeExtracterOutput);

        return boundary;
    }

    public String getStartTime()
    {
        return startTime;
    }

    public String getStopTime()
    {
        return stopTime;
    }

    public double getMinimumHorizontalPixelScale()
    {
        return minHorizontalPixelScale;
    }

    public double getMaximumHorizontalPixelScale()
    {
        return maxHorizontalPixelScale;
    }

    public double getMeanHorizontalPixelScale()
    {
        return meanHorizontalPixelScale;
    }

    public double getMinimumVerticalPixelScale()
    {
        return minVerticalPixelScale;
    }

    public double getMaximumVerticalPixelScale()
    {
        return maxVerticalPixelScale;
    }

    public double getMeanVerticalPixelScale()
    {
        return meanVerticalPixelScale;
    }

    public double getSpacecraftDistance()
    {
        return MathUtil.vnorm(spacecraftPosition);
     }

    private void computeCellNormals()
    {
        if (normalsGenerated == false)
        {
            normalsFilter.SetInput(footprint);
            normalsFilter.SetComputeCellNormals(1);
            normalsFilter.SetComputePointNormals(0);
            normalsFilter.SplittingOff();
            normalsFilter.Update();

            vtkPolyData normalsFilterOutput = normalsFilter.GetOutput();
            footprint.DeepCopy(normalsFilterOutput);
            normalsGenerated = true;
        }
    }

    // Computes the incidence, emission, and phase at a point with a given normal.
    // The output is a 3-vector with the first component equal to the incidence,
    // the second component equal to the emission and the third component equal to
    // the phase.
    private double[] computeIlluminationAnglesAtPoint(
            double[] pt,
            double[] normal)
    {
        double[] scvec = {
            spacecraftPosition[0] - pt[0],
            spacecraftPosition[1] - pt[1],
            spacecraftPosition[2] - pt[2]};

        double incidence = MathUtil.vsep(normal, sunVector) * 180.0 / Math.PI;
        double emission = MathUtil.vsep(normal, scvec) * 180.0 / Math.PI;
        double phase = MathUtil.vsep(sunVector, scvec) * 180.0 / Math.PI;

        double[] angles = {incidence, emission, phase};

        return angles;
    }

    protected void computeIlluminationAngles()
    {
        if (footprintGenerated == false)
            loadFootprint();

        computeCellNormals();

        int numberOfCells = footprint.GetNumberOfCells();

        vtkPoints points = footprint.GetPoints();
        vtkDataArray normals = footprint.GetCellData().GetNormals();

        this.minEmission  =  Double.MAX_VALUE;
        this.maxEmission  = -Double.MAX_VALUE;
        this.minIncidence =  Double.MAX_VALUE;
        this.maxIncidence = -Double.MAX_VALUE;
        this.minPhase     =  Double.MAX_VALUE;
        this.maxPhase     = -Double.MAX_VALUE;

        for (int i=0; i<numberOfCells; ++i)
        {
            vtkCell cell = footprint.GetCell(i);
            double[] pt0 = points.GetPoint( cell.GetPointId(0) );
            double[] pt1 = points.GetPoint( cell.GetPointId(1) );
            double[] pt2 = points.GetPoint( cell.GetPointId(2) );
            double[] centroid = {
                    (pt0[0] + pt1[0] + pt2[0]) / 3.0,
                    (pt0[1] + pt1[1] + pt2[1]) / 3.0,
                    (pt0[2] + pt1[2] + pt2[2]) / 3.0
            };
            double[] normal = normals.GetTuple3(i);

            double[] angles = computeIlluminationAnglesAtPoint(centroid, normal);
            double incidence = angles[0];
            double emission  = angles[1];
            double phase     = angles[2];

            if (incidence < minIncidence)
                minIncidence = incidence;
            if (incidence > maxIncidence)
                maxIncidence = incidence;
            if (emission < minEmission)
                minEmission = emission;
            if (emission > maxEmission)
                maxEmission = emission;
            if (phase < minPhase)
                minPhase = phase;
            if (phase > maxPhase)
                maxPhase = phase;
        }
    }

    protected void computePixelScale()
    {
        if (footprintGenerated == false)
            loadFootprint();

        int numberOfPoints = footprint.GetNumberOfPoints();

        vtkPoints points = footprint.GetPoints();

        minHorizontalPixelScale = Double.MAX_VALUE;
        maxHorizontalPixelScale = -Double.MAX_VALUE;
        meanHorizontalPixelScale = 0.0;
        minVerticalPixelScale = Double.MAX_VALUE;
        maxVerticalPixelScale = -Double.MAX_VALUE;
        meanVerticalPixelScale = 0.0;

        double horizScaleFactor = 2.0 * Math.tan( MathUtil.vsep(frustum1, frustum3) / 2.0 ) / imageHeight;
        double vertScaleFactor = 2.0 * Math.tan( MathUtil.vsep(frustum1, frustum2) / 2.0 ) / imageWidth;

        double[] vec = new double[3];

        for (int i=0; i<numberOfPoints; ++i)
        {
            double[] pt = points.GetPoint(i);

            vec[0] = pt[0] - spacecraftPosition[0];
            vec[1] = pt[1] - spacecraftPosition[1];
            vec[2] = pt[2] - spacecraftPosition[2];
            double dist = MathUtil.vnorm(vec);

            double horizPixelScale = dist * horizScaleFactor;
            double vertPixelScale = dist * vertScaleFactor;

            if (horizPixelScale < minHorizontalPixelScale)
                minHorizontalPixelScale = horizPixelScale;
            if (horizPixelScale > maxHorizontalPixelScale)
                maxHorizontalPixelScale = horizPixelScale;
            if (vertPixelScale < minVerticalPixelScale)
                minVerticalPixelScale = vertPixelScale;
            if (vertPixelScale > maxVerticalPixelScale)
                maxVerticalPixelScale = vertPixelScale;

            meanHorizontalPixelScale += horizPixelScale;
            meanVerticalPixelScale += vertPixelScale;
        }

        meanHorizontalPixelScale /= (double)numberOfPoints;
        meanVerticalPixelScale /= (double)numberOfPoints;
    }

    public float[] generateBackplanes()
    {
        return generateBackplanes(false);
    }

    /**
     * If <code>returnNullIfContainsLimb</code> then return null if any ray
     * in the direction of a pixel in the image does not intersect the asteroid.
     * By setting this boolean to true, you can (usually) determine whether or not the
     * image contains a limb without having to compute the entire backplane. Note
     * that this is a bit of a hack and a better way is needed to quickly determine
     * if there is a limb.
     *
     * @param returnNullIfContainsLimb
     * @return
     */
    private float[] generateBackplanes(boolean returnNullIfContainsLimb)
    {
        // We need to use cell normals not point normals for the calculations
        vtkDataArray normals = null;
        if (!returnNullIfContainsLimb)
            normals = smallBodyModel.getCellNormals();

        int numLayers = 16;
        float[] data = new float[numLayers*imageHeight*imageWidth];

        vtksbCellLocator cellLocator = smallBodyModel.getCellLocator();

        //vtkPoints intersectPoints = new vtkPoints();
        //vtkIdList intersectCells = new vtkIdList();
        vtkGenericCell cell = new vtkGenericCell();

        // For each pixel in the image we need to compute the vector
        // from the spacecraft pointing in the direction of that pixel.
        // To do this, for each row in the image compute the left and
        // right vectors of the entire row. Then for each pixel in
        // the row use the two vectors from either side to compute
        // the vector of that pixel.
        double[] corner1 = {
                spacecraftPosition[0] + frustum1[0],
                spacecraftPosition[1] + frustum1[1],
                spacecraftPosition[2] + frustum1[2]
        };
        double[] corner2 = {
                spacecraftPosition[0] + frustum2[0],
                spacecraftPosition[1] + frustum2[1],
                spacecraftPosition[2] + frustum2[2]
        };
        double[] corner3 = {
                spacecraftPosition[0] + frustum3[0],
                spacecraftPosition[1] + frustum3[1],
                spacecraftPosition[2] + frustum3[2]
        };
        double[] vec12 = {
                corner2[0] - corner1[0],
                corner2[1] - corner1[1],
                corner2[2] - corner1[2]
        };
        double[] vec13 = {
                corner3[0] - corner1[0],
                corner3[1] - corner1[1],
                corner3[2] - corner1[2]
        };

        double horizScaleFactor = 2.0 * Math.tan( MathUtil.vsep(frustum1, frustum3) / 2.0 ) / imageHeight;
        double vertScaleFactor = 2.0 * Math.tan( MathUtil.vsep(frustum1, frustum2) / 2.0 ) / imageWidth;

        double scdist = MathUtil.vnorm(spacecraftPosition);

        for (int i=0; i<imageHeight; ++i)
        {
            // Compute the vector on the left of the row.
            double fracHeight = ((double)i / (double)(imageHeight-1));
            double[] left = {
                    corner1[0] + fracHeight*vec13[0],
                    corner1[1] + fracHeight*vec13[1],
                    corner1[2] + fracHeight*vec13[2]
            };

            for (int j=0; j<imageWidth; ++j)
            {
                // If we're just trying to know if there is a limb, we
                // only need to do intersections around the boundary of
                // the backplane, not the interior pixels.
                if (returnNullIfContainsLimb)
                {
                    if (j == 1 && i > 0 && i < imageHeight-1)
                    {
                        j = imageWidth-2;
                        continue;
                    }
                }

                double fracWidth = ((double)j / (double)(imageWidth-1));
                double[] vec = {
                        left[0] + fracWidth*vec12[0],
                        left[1] + fracWidth*vec12[1],
                        left[2] + fracWidth*vec12[2]
                };
                vec[0] -= spacecraftPosition[0];
                vec[1] -= spacecraftPosition[1];
                vec[2] -= spacecraftPosition[2];
                MathUtil.unorm(vec, vec);

                double[] lookPt = {
                        spacecraftPosition[0] + 2.0*scdist*vec[0],
                        spacecraftPosition[1] + 2.0*scdist*vec[1],
                        spacecraftPosition[2] + 2.0*scdist*vec[2]
                };

                //cellLocator.IntersectWithLine(spacecraftPosition, lookPt, intersectPoints, intersectCells);
                double tol = 1e-6;
                double[] t = new double[1];
                double[] x = new double[3];
                double[] pcoords = new double[3];
                int[] subId = new int[1];
                int[] cellId = new int[1];
                int result = cellLocator.IntersectWithLine(spacecraftPosition, lookPt, tol, t, x, pcoords, subId, cellId, cell);

                //if (intersectPoints.GetNumberOfPoints() == 0)
                //    System.out.println(i + " " + j + " " + intersectPoints.GetNumberOfPoints());

                //int numberOfPoints = intersectPoints.GetNumberOfPoints();

                if (result > 0)
                {
                    // If we're just trying to know if there is a limb, do not
                    // compute the values of the backplane (It will crash since
                    // we don't have normals of the asteroid itself)
                    if (returnNullIfContainsLimb)
                        continue;

                    //double[] closestPoint = intersectPoints.GetPoint(0);
                    //int closestCell = intersectCells.GetId(0);
                    double[] closestPoint = x;
                    int closestCell = cellId[0];
                    double closestDist = MathUtil.distanceBetween(closestPoint, spacecraftPosition);

                    /*
                    // compute the closest point to the spacecraft of all the intersecting points.
                    if (numberOfPoints > 1)
                    {
                        for (int k=1; k<numberOfPoints; ++k)
                        {
                            double[] pt = intersectPoints.GetPoint(k);
                            double dist = GeometryUtil.distanceBetween(pt, spacecraftPosition);
                            if (dist < closestDist)
                            {
                                closestDist = dist;
                                closestCell = intersectCells.GetId(k);
                                closestPoint = pt;
                            }
                        }
                    }
                    */

                    LatLon llr = MathUtil.reclat(closestPoint);
                    double lon = llr.lon*180/Math.PI;
                    if (lon < 0.0)
                        lon += 360.0;

                    double[] normal = normals.GetTuple3(closestCell);
                    double[] illumAngles = computeIlluminationAnglesAtPoint(closestPoint, normal);

                    double horizPixelScale = closestDist * horizScaleFactor;
                    double vertPixelScale = closestDist * vertScaleFactor;

                    double[] coloringValues = smallBodyModel.getAllColoringValues(closestPoint);

                    data[index(j,i,0)]  = (float)rawImage.GetScalarComponentAsFloat(j, i, 0, 0);
                    data[index(j,i,1)]  = (float)closestPoint[0];
                    data[index(j,i,2)]  = (float)closestPoint[1];
                    data[index(j,i,3)]  = (float)closestPoint[2];
                    data[index(j,i,4)]  = (float)(llr.lat * 180.0 / Math.PI);
                    data[index(j,i,5)]  = (float)(lon);
                    data[index(j,i,6)]  = (float)(llr.rad);
                    data[index(j,i,7)]  = (float)(illumAngles[0] * 180.0 / Math.PI);
                    data[index(j,i,8)]  = (float)(illumAngles[1] * 180.0 / Math.PI);
                    data[index(j,i,9)]  = (float)(illumAngles[2] * 180.0 / Math.PI);
                    data[index(j,i,10)] = (float)(horizPixelScale);
                    data[index(j,i,11)] = (float)(vertPixelScale);
                    data[index(j,i,12)] = (float)coloringValues[0]; // slope
                    data[index(j,i,13)] = (float)coloringValues[1]; // elevation;
                    data[index(j,i,14)] = (float)coloringValues[2]; // grav acc;
                    data[index(j,i,15)] = (float)coloringValues[3]; // grav pot;
                }
                else
                {
                    if (returnNullIfContainsLimb)
                        return null;

                    for (int k=0; k<numLayers; ++k)
                        data[index(j,i,k)] = PDS_NA;
                }
            }
        }

        return data;
    }

    public int index(int i, int j, int k)
    {
        return ((k * imageHeight + j) * imageWidth + i);
    }

    public void propertyChange(PropertyChangeEvent evt)
    {
        if (Properties.MODEL_RESOLUTION_CHANGED.equals(evt.getPropertyName()))
        {
            loadFootprint();
            normalsGenerated = false;
            this.minEmission  =  Double.MAX_VALUE;
            this.maxEmission  = -Double.MAX_VALUE;
            this.minIncidence =  Double.MAX_VALUE;
            this.maxIncidence = -Double.MAX_VALUE;
            this.minPhase     =  Double.MAX_VALUE;
            this.maxPhase     = -Double.MAX_VALUE;
            this.minHorizontalPixelScale = Double.MAX_VALUE;
            this.maxHorizontalPixelScale = -Double.MAX_VALUE;
            this.minVerticalPixelScale = Double.MAX_VALUE;
            this.maxVerticalPixelScale = -Double.MAX_VALUE;
            this.meanHorizontalPixelScale = 0.0;
            this.meanVerticalPixelScale = 0.0;

            this.pcs.firePropertyChange(Properties.MODEL_CHANGED, null, null);
        }
    }

    /**
     * The shifted footprint is the original footprint shifted slightly in the
     * normal direction so that it will be rendered correctly and not obscured
     * by the asteroid.
     * @return
     */
    public vtkPolyData getShiftedFootprint()
    {
        return shiftedFootprint;
    }

    /**
     * The original footprint whose cells exactly overlap the original asteroid.
     * If rendered as is, it would interfere with the asteroid.
     * @return
     */
    public vtkPolyData getUnshiftedFootprint()
    {
        return footprint;
    }

    public void Delete()
    {
        displayedImage.Delete();
        rawImage.Delete();
        footprint.Delete();
        shiftedFootprint.Delete();
        textureCoords.Delete();
        normalsFilter.Delete();
    }

    public void getCameraOrientation(double[] spacecraftPosition,
            double[] focalPoint, double[] upVector)
    {

        for (int i=0; i<3; ++i)
        {
            spacecraftPosition[i] = this.spacecraftPosition[i];
            upVector[i] = this.upVector[i];
        }

        // Normalize the direction vector
        double[] direction = new double[3];
        MathUtil.unorm(boresightDirection, direction);

        int cellId = smallBodyModel.computeRayIntersection(spacecraftPosition, direction, focalPoint);

        if (cellId < 0)
        {
            BoundingBox bb = new BoundingBox(footprint.GetBounds());
            double[] centerPoint = bb.getCenterPoint();
            //double[] centerPoint = footprint.GetPoint(0);
            double distanceToCenter = MathUtil.distanceBetween(spacecraftPosition, centerPoint);

            focalPoint[0] = spacecraftPosition[0] + distanceToCenter*direction[0];
            focalPoint[1] = spacecraftPosition[1] + distanceToCenter*direction[1];
            focalPoint[2] = spacecraftPosition[2] + distanceToCenter*direction[2];
        }
    }

    public Frustum getFrustum()
    {
        return new Frustum(spacecraftPosition, frustum1, frustum3, frustum4, frustum2);
    }

    /**
     *  Get the maximum FOV angle in degrees of the image. I.e., return the
     *  angular separation in degrees between two corners of the frustum where the
     *  two corners are both on the longer side.
     *
     * @return
     */
    public double getFovAngle()
    {
        double fov = Math.max(Math.abs(getFovParameter1()), Math.abs(getFovParameter2()));

        double[] v1 = {fov, fov, 1.0};
        double[] v2 = {-fov, fov, 1.0};

        return MathUtil.vsep(v1, v2) * 180.0 / Math.PI;
    }

    public String getImageName()
    {
        return new File(key.name).getName();
    }

    public double[] getSpacecraftPosition()
    {
        return spacecraftPosition;
    }

    public double[] getSunVector()
    {
        return sunVector;
    }

    public double[] getBoresightDirection()
    {
        return boresightDirection;
    }

    public double[] getUpVector()
    {
        return upVector;
    }

    public void setInterpolate(boolean enable)
    {
        vtkTexture texture = footprintActor.GetTexture();
        if (texture != null)
        {
            texture.SetInterpolate(enable ? 1 : 0);
            this.pcs.firePropertyChange(Properties.MODEL_CHANGED, null, null);
        }
    }

    public boolean getInterpolate()
    {
        vtkTexture texture = footprintActor.GetTexture();
        if (texture != null)
            return texture.GetInterpolate() == 0 ? false : true;
        else
            return true;
    }
}
